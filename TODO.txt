* More testing under Windows.  Or any, really...

* If a publication is interrupted while waiting for initial funds, the funds could be confirmed later, but would be lost (!).  Code is needed to either continue publication or refund the user (refunding is probably easier).

* Detect if Python2 was mistakenly used.

* Check if all compression programs are available at run time.

* Migrate from polling RPC server during publication to a callback architecture.

* Add functionality to search for content through specific ranges of the blockchain.

* Create ECDSA keys directly so that the wallet does not get polluted (note that wallet key deletion is not supported by Bitcoin).

* Add a process to closely monitor unconfirmed transactions in mempool for deadman switch keys.

* Add a timeout for PartialFiles.  After, say, X months of no activity and/or Y months since initializing, the publication should be considered failed and no longer tracked.

* Clear interesting TXIDs from PartialFiles when deadman switch files are published.

* Continuation messages should have nonce for unencrypted publications.

* Nonces should be larger.

* Try to delete interesting TXIDs in blockchain_watcher.py after they are used, if possible.

* Add unit tests:
   * Ensure blockchain forks & rollbacks handled correctly.
   * Support the case where initial funds are sent via multiple transactions.
   * Filenames can be changed.
   * Descriptions can be set.
   * Filenames with malicious paths don't break stuff.
   * Encryption happens by default.
   * Plaintext publishing works.
   * Automatic compression type detection works.
   * Specific compression type can be selected.
   * Compression can be disabled.
   * Automatic content type detection works.
   * Specific content type can be selected.
   * Restore a deadman switch publication.
